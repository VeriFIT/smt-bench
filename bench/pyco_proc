#!/usr/bin/env python3


import argparse
import csv
import sys
from tabulate import tabulate
from enum import Enum
from pathlib import Path
import datetime

from z3_statistics import Z3StatisticsParser, StatsFormat

#  fmt = 'text'
fmt = 'csv'

# number of parameters of execution
PARAMS_NUM = 1


class RunResult(Enum):
    """Result of a benchmark instance run."""
    FINISHED = 1
    ERROR = 2
    TIMEOUT = 3


###########################################
def proc_res(fd, args):
    """proc_res(fd, args) -> _|_

    processes results of pycobench from file descriptor 'fd' using command line
    arguments 'args'
"""

    reader = csv.reader(
        fd, delimiter=';', quotechar='"',
        doublequote=False, quoting=csv.QUOTE_MINIMAL)

    engines = list()
    engines_outs = dict()
    results = dict()

    current_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    Path(f"./stats/{current_time}/").mkdir(parents=True, exist_ok=True)
    for row in reader:
        assert len(row) >= 1 + 1 + PARAMS_NUM  # status + engine name + params
        status, eng = row[0], row[1]
        params = tuple(row[2:(PARAMS_NUM+2)])
        row_tail = row[(PARAMS_NUM+2):]
        if params not in results:
            results[params] = dict()
        if eng not in engines:
            engines.append(eng)
            engines_outs[eng] = list()

        # we don't have some results twice
        assert eng not in results[params]

        if status == 'finished':
            retcode, out, err, runtime = row_tail[0], row_tail[1], \
                                         row_tail[2], row_tail[3]

            eng_res = dict()
            eng_res["runtime"] = runtime
            eng_res["retcode"] = retcode
            eng_res["error"] = err
            eng_res["output"] = dict()
            eng_res["run_result"] = RunResult.FINISHED

            out_lines = out.split("###")
            reading_inner_block = False
            inner_block = ""
            for line in out_lines:
                if reading_inner_block:
                    inner_block += line + "\n"
                    if line.endswith(")"):
                        reading_inner_block = False
                        eng_res["output"][f"{engines_outs[eng][-1]}-stats"] = Z3StatisticsParser(inner_block).stats
                        inner_block = ""
                elif line.startswith("(:"):
                    reading_inner_block = True
                    inner_block += line + "\n"
                else:
                    spl = line.split(':', 1)
                    if len(spl) != 2:  # jump over lines not in the format
                        continue
                    name, val = spl[0].strip(), spl[1].strip()
                    assert name not in eng_res["output"]
                    if name not in engines_outs[eng]:
                        engines_outs[eng].append(name)
                    eng_res["output"][name] = val

            results[params][eng] = eng_res
        elif status == 'error':
            results[params][eng]["run_result"] = RunResult.ERROR
        elif status == 'timeout':
            results[params][eng]["run_result"] = RunResult.TIMEOUT


    list_ptrns = list()
    for bench in results:
        all_engs = True
        ls = list(bench)
        for eng in engines:
            out_len = len(engines_outs[eng]) + 1    # +1 = time
            if eng in results[bench]:
                bench_res = results[bench][eng]
                for out in engines_outs[eng]:
                    if f"{out}-stats" in bench_res["output"]:
                        bench_res["output"][f"{out}-stats"] = \
                            Z3StatisticsParser.stats_formatter(bench_res["output"][f"{out}-stats"], StatsFormat.JSON)

                if bench_res["run_result"] == RunResult.ERROR:
                    for i in range(out_len):
                        ls.append("ERR")
                elif bench_res["run_result"] == RunResult.TIMEOUT:
                    for i in range(out_len):
                        ls.append("TO")
                else:
                    assert type(bench_res) == dict
                    assert "output" in bench_res

                    ls.append(bench_res["runtime"])
                    for out in engines_outs[eng]:
                        if out in bench_res["output"]:
                            out_data = bench_res["output"][out]
                            ls.append(out_data)

                            if f"{out}-stats" in bench_res["output"]:
                                stats_file_name = f"{eng}-{bench[0].replace("/", "_").replace(".", "_")}-stats.json"
                                with open(f"./stats/{current_time}/{stats_file_name}", "w") as f:
                                    f.write(bench_res["output"][f"{out}-stats"])
                        else:
                            sys.stderr.write("Warning: in {} and {}: "
                                "element {} not in {}\n".format(bench, eng,
                                out, bench_res["output"]))
                            ls.append("MISSING")
                            # assert False
            else:
                all_engs = False
                for i in range(out_len):
                    ls.append("MISSING")

        # prepend with status of the benchmark
        if args.tick:
            if all_engs:
                ls = ["T"] + ls
            else:
                ls = ["F"] + ls

        list_ptrns.append(ls)

    header = list()
    if args.tick:
        header += ["T"]

    header += ['name']
    for eng in engines:
        header += [eng + "-runtime"]
        for out in engines_outs[eng]:
            if "stats" in out:
                header += [eng + "-stats"]
            else:
                header += [eng + "-" + out]

    fmt = "text"
    if args.csv:
        fmt = "csv"
    if args.text:
        fmt = "text"
    if args.html:
        fmt = "html"

    if fmt == 'html':
        print(tabulate(list_ptrns, header, tablefmt='html'))
    elif fmt == 'text':
        print(tabulate(list_ptrns, header, tablefmt='text'))
    elif fmt == 'csv':
        writer = csv.writer(
            sys.stdout, delimiter=';', quotechar='"', escapechar='\\',
            doublequote=False, quoting=csv.QUOTE_MINIMAL)
        writer.writerow(header)
        writer.writerows(list_ptrns)
    else:
        raise Exception('Invalid output format: "{}"'.format(fmt))
    return


###############################
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='''proc_results.py - \
Processes results of benchmarks from pycobench''')
    parser.add_argument('results', metavar='result-file', nargs='?',
                        help='file with results (output of pycobench) (default: %(default)s)',
                        type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument('--csv', action="store_true",
                        help='output in CSV')
    parser.add_argument('--text', action="store_true",
                        help='output in text')
    parser.add_argument('--html', action="store_true",
                        help='output in HTML')
    parser.add_argument('--tick', action="store_true",
                        help='tick finished benchmarks (usable for filtering)')
    args = parser.parse_args()

    proc_res(args.results, args)
